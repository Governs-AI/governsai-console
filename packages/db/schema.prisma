generator client {
  provider        = "prisma-client-js"
  output          = "./node_modules/.prisma/client"
  binaryTargets   = ["native", "rhel-openssl-3.0.x"]
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [vector]
}

model Org {
  id                   String                @id @default(cuid())
  name                 String                @unique
  slug                 String                @unique
  createdAt            DateTime              @default(now())
  updatedAt            DateTime              @updatedAt
  // Budget configuration
  budgetEnabled        Boolean               @default(true)
  budgetOnError        String                @default("block") // "block" | "pass"
  apiKeys              APIKey[]
  networkRules         NetworkAccessRule[]
  memberships          OrgMembership[]
  channels             WebSocketChannel[]
  sessions             WebSocketSession[]
  passkeys             Passkey[]
  pendingConfirmations PendingConfirmation[]
  budgetLimits         BudgetLimit[]
  budgetAlerts         BudgetAlert[]
  usageRecords         UsageRecord[]
  tools                Tool[]
  purchaseRecords      PurchaseRecord[]
  contextMemory        ContextMemory[]
  conversations        Conversation[]
  contextAccessLog     ContextAccessLog[]
  documents            Document[]
}

model User {
  id                   String                @id @default(cuid())
  email                String                @unique
  emailVerified        DateTime?
  name                 String?
  image                String?
  createdAt            DateTime              @default(now())
  updatedAt            DateTime              @updatedAt
  apiKeys              APIKey[]
  auditLogs            AuditLog[]
  budgets              Budget[]
  credential           Credential?
  mfaTotp              MfaTotp?
  memberships          OrgMembership[]
  usageRecords         UsageRecord[]
  channels             WebSocketChannel[]
  sessions             WebSocketSession[]
  passkeys             Passkey[]
  pendingConfirmations PendingConfirmation[]
  budgetLimits         BudgetLimit[]
  budgetAlerts         BudgetAlert[]
  purchaseRecords      PurchaseRecord[]
  contextMemory        ContextMemory[]
  conversations        Conversation[]
  contextAccessLog     ContextAccessLog[]
  documents            Document[]
}

model Credential {
  id            String    @id @default(cuid())
  userId        String    @unique
  passwordHash  String
  passwordSetAt DateTime  @default(now())
  resetToken    String?   @unique
  resetTokenExp DateTime?
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model OrgMembership {
  id        String   @id @default(cuid())
  orgId     String
  userId    String
  role      OrgRole  @default(VIEWER)
  createdAt DateTime @default(now())
  org       Org      @relation(fields: [orgId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([orgId, userId])
  @@index([userId])
  @@index([orgId, role])
}

model VerificationToken {
  id        String   @id @default(cuid())
  email     String
  token     String   @unique
  purpose   String  // "email-verify" | "invite"
  orgId     String?
  role      OrgRole?
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([email, purpose])
}

model MfaTotp {
  id           String   @id @default(cuid())
  userId       String   @unique
  secretBase32 String  // store encrypted-at-rest
  enabled      Boolean  @default(false)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Passkey {
  id           String    @id @default(cuid())
  userId       String    @map("user_id")
  orgId        String    @map("org_id")
  credentialId String    @unique @map("credential_id") // Base64url-encoded credential ID from WebAuthn
  publicKey    Bytes     @map("public_key") // Public key for verification
  counter      BigInt    @default(0) // Signature counter (replay protection)
  transports   String[]  @default([]) // ["usb", "nfc", "ble", "internal"]
  deviceName   String    @default("Unnamed Device") @map("device_name")
  aaguid       String? // Authenticator AAGUID
  createdAt    DateTime  @default(now()) @map("created_at")
  lastUsedAt   DateTime? @map("last_used_at")
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  org          Org       @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@index([userId, orgId])
  @@index([credentialId])
  @@map("passkeys")
}

model PendingConfirmation {
  id                String    @id @default(cuid())
  correlationId     String    @unique @map("correlation_id") // From precheck
  userId            String    @map("user_id")
  orgId             String    @map("org_id")
  apiKeyId          String    @map("api_key_id") // Which API key made the request
  requestType       String    @map("request_type") // "chat", "tool_call", "api"
  requestDesc       String    @map("request_desc") // Human-readable description
  requestPayload    Json      @map("request_payload") // Store original messages/args
  decision          String    @default("confirm")
  reasons           Json      @default("[]")
  challenge         String    @unique // Base64-encoded WebAuthn challenge
  status            String    @default("pending") // "pending", "approved", "denied", "expired", "cancelled", "consumed"
  approvedAt        DateTime? @map("approved_at")
  consumedAt        DateTime? @map("consumed_at")
  passkeyId         String?   @map("passkey_id") // Which passkey was used (if approved)
  confirmationToken String?   @unique @map("confirmation_token") // JWT token issued on approval
  expiresAt         DateTime  @map("expires_at")
  createdAt         DateTime  @default(now()) @map("created_at")
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  org               Org       @relation(fields: [orgId], references: [id], onDelete: Cascade)
  apiKey            APIKey    @relation(fields: [apiKeyId], references: [id], onDelete: Cascade)

  @@index([correlationId])
  @@index([userId, status])
  @@index([expiresAt])
  @@index([challenge])
  @@index([confirmationToken])
  @@map("pending_confirmations")
}

model APIKey {
  id                   String                @id @default(cuid())
  key                  String                @unique
  keyHash              String?               @unique
  name                 String
  userId               String
  orgId                String                @map("org_id")
  scopes               String[]              @default([])
  env                  String                @default("prod")
  isActive             Boolean               @default(true)
  lastUsed             DateTime?
  ipAllow              Json?
  createdAt            DateTime              @default(now())
  updatedAt            DateTime              @updatedAt
  expiresAt            DateTime?
  org                  Org                   @relation(fields: [orgId], references: [id], onDelete: Cascade)
  user                 User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  usageRecords         UsageRecord[]
  channels             WebSocketChannel[]
  pendingConfirmations PendingConfirmation[]
  purchaseRecords      PurchaseRecord[]

  @@index([key])
  @@index([keyHash])
  @@index([userId])
  @@index([orgId])
  @@index([isActive])
  @@index([lastUsed])
}

model NetworkAccessRule {
  id        String    @id @default(cuid())
  orgId     String    @map("org_id")
  kind      String
  value     String
  label     String?
  notes     String?
  isActive  Boolean   @default(true)
  expiresAt DateTime?
  createdBy String?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  org       Org       @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@index([orgId, kind, isActive])
  @@index([orgId, expiresAt])
  @@index([isActive])
}

model AIProvider {
  id           String        @id @default(cuid())
  name         String        @unique
  baseUrl      String
  isActive     Boolean       @default(true)
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  usageRecords UsageRecord[]
}

model UsageRecord {
  id            String   @id @default(cuid())
  userId        String
  orgId         String   @map("org_id")
  provider      String   // "openai", "anthropic", "ollama", "local"
  model         String   // "gpt-4", "claude-3-opus", "llama2"
  inputTokens   Int      @map("input_tokens")
  outputTokens  Int      @map("output_tokens")
  cost          Decimal  @db.Decimal(10, 6) // Supports $0.000001 precision
  costType      String   @default("external") @map("cost_type") // "external", "internal", "free"
  tool          String?  // Tool name if this was a tool call
  correlationId String?  @map("correlation_id")
  timestamp     DateTime @default(now())
  metadata      Json     @default("{}") // Additional context
  apiKeyId      String?  @map("api_key_id")
  providerId    String?  @map("provider_id") // Optional relation to AIProvider

  // Relations
  user      User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  org       Org         @relation(fields: [orgId], references: [id], onDelete: Cascade)
  apiKey    APIKey?     @relation(fields: [apiKeyId], references: [id])
  aiProvider AIProvider? @relation(fields: [providerId], references: [id])

  @@index([orgId, timestamp(sort: Desc)])
  @@index([userId, timestamp(sort: Desc)])
  @@index([provider])
  @@index([tool])
  @@index([correlationId])
}

model Budget {
  id         String   @id @default(cuid())
  userId     String
  orgId      String   @map("org_id")
  name       String
  amount     Float
  usedAmount Float    @default(0)
  period     String
  isActive   Boolean  @default(true)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([orgId])
}

model BudgetLimit {
  id           String   @id @default(cuid())
  orgId        String   @map("org_id")
  userId       String?  @map("user_id")
  type         String   // "organization" | "user"
  monthlyLimit Decimal  @db.Decimal(10, 2) // Monthly spending limit in dollars
  alertAt      Decimal? @db.Decimal(10, 2) @map("alert_at") // Send alert when this amount is reached
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  org          Org      @relation(fields: [orgId], references: [id], onDelete: Cascade)
  user         User?    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([orgId, userId]) // One limit per org-user combination
  @@index([orgId])
  @@index([userId])
}

model PurchaseRecord {
  id            String   @id @default(cuid())
  userId        String
  orgId         String   @map("org_id")
  tool          String   // Tool that made the purchase
  amount        Decimal  @db.Decimal(10, 2) // Purchase amount in dollars
  currency      String   @default("USD")
  description   String?  // What was purchased
  vendor        String?  // Who was paid
  category      String?  // Purchase category (software, hardware, services, etc.)
  correlationId String?  @map("correlation_id")
  timestamp     DateTime @default(now())
  metadata      Json     @default("{}") // Additional context
  apiKeyId      String?  @map("api_key_id")

  // Relations
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)
  org    Org  @relation(fields: [orgId], references: [id], onDelete: Cascade)
  apiKey APIKey? @relation(fields: [apiKeyId], references: [id])

  @@index([orgId, timestamp(sort: Desc)])
  @@index([userId, timestamp(sort: Desc)])
  @@index([tool])
  @@index([correlationId])
  @@index([category])
}

model BudgetAlert {
  id        String   @id @default(cuid())
  orgId     String   @map("org_id")
  userId    String?  @map("user_id")
  type      String   // "threshold_reached" | "budget_exceeded" | "unusual_spike"
  message   String
  threshold Decimal? @db.Decimal(10, 2)
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now())

  org  Org   @relation(fields: [orgId], references: [id], onDelete: Cascade)
  user User? @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([orgId, isRead])
  @@index([userId, isRead])
}

model Tool {
  id               String   @id @default(cuid())
  orgId            String   @map("org_id")
  name             String
  displayName      String?  @map("display_name")
  description      String?
  category         String
  riskLevel        String   @map("risk_level")
  scope            String
  direction        String   @default("both")
  metadata         Json     @default("{}")
  requiresApproval Boolean  @default(false) @map("requires_approval")
  isActive         Boolean  @default(true)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  org              Org      @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@index([orgId])
  @@index([category])
  @@index([riskLevel])
  @@index([scope])
  @@index([isActive])
  @@unique([orgId, name])
}

model AuditLog {
  id        String   @id @default(cuid())
  userId    String?
  orgId     String?  @map("org_id")
  action    String
  resource  String
  details   Json?
  createdAt DateTime @default(now())
  user      User?    @relation(fields: [userId], references: [id])

  @@index([userId, createdAt])
  @@index([orgId, createdAt])
  @@index([action, createdAt])
}

model Policy {
  id            String   @id @default(cuid())
  orgId         String   @map("org_id")
  userId        String?  @map("user_id")
  name          String
  description   String?
  version       String   @default("v1")
  defaults      Json
  toolAccess    Json     @default("{}") @map("tool_access")
  denyTools     Json     @default("[]") @map("deny_tools")
  allowTools    Json     @default("[]") @map("allow_tools")
  networkScopes Json     @default("[]") @map("network_scopes")
  networkTools  Json     @default("[]") @map("network_tools")
  onError       String   @default("block") @map("on_error")
  isActive      Boolean  @default(true)
  priority      Int      @default(0)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([orgId])
  @@index([userId])
  @@index([orgId, isActive])
  @@index([orgId, userId, isActive])
  @@index([priority])
}

model ToolConfig {
  id               String   @id @default(cuid())
  toolName         String   @unique @map("tool_name")
  displayName      String?  @map("display_name")
  description      String?
  category         String
  riskLevel        String   @map("risk_level")
  scope            String
  direction        String   @default("both")
  metadata         Json     @default("{}")
  requiresApproval Boolean  @default(false) @map("requires_approval")
  isActive         Boolean  @default(true)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  @@index([category])
  @@index([riskLevel])
  @@index([scope])
  @@index([isActive])
}

model Decision {
  id              String   @id @default(cuid())
  orgId           String   @map("org_id")
  direction       String
  decision        String
  tool            String?
  scope           String?
  detectorSummary Json     @default("{}") @map("detector_summary")
  payloadHash     String   @map("payload_hash")
  payloadOut      Json?    @map("payload_out")
  reasons         Json?    @default("[]")
  policyId        String?  @map("policy_id")
  latencyMs       Int?     @map("latency_ms")
  correlationId   String?  @map("correlation_id")
  tags            Json     @default("[]")
  ts              DateTime @default(now())

  @@index([orgId, ts(sort: Desc)])
  @@index([decision])
  @@index([direction])
  @@index([tool])
  @@index([correlationId])
  @@index([policyId])
}

model WebSocketGateway {
  id          String             @id @default(cuid())
  name        String
  url         String
  isActive    Boolean            @default(true)
  description String?
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt
  sessions    WebSocketSession[]

  @@index([isActive])
}

model WebSocketChannel {
  id          String   @id @default(cuid())
  orgId       String?  @map("org_id")
  userId      String?  @map("user_id")
  keyId       String?  @map("key_id")
  channelType String
  channelName String
  isActive    Boolean  @default(true)
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  key         APIKey?  @relation(fields: [keyId], references: [id], onDelete: Cascade)
  org         Org?     @relation(fields: [orgId], references: [id], onDelete: Cascade)
  user        User?    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([orgId])
  @@index([userId])
  @@index([keyId])
  @@index([channelType])
  @@index([channelType, channelName])
  @@index([orgId, isActive])
  @@index([userId, isActive])
  @@index([keyId, isActive])
}

model WebSocketSession {
  id        String           @id @default(cuid())
  userId    String
  orgId     String?          @map("org_id")
  sessionId String           @unique
  gatewayId String
  channels  Json
  cursor    Json?
  isActive  Boolean          @default(true)
  lastSeen  DateTime         @default(now())
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt
  gateway   WebSocketGateway @relation(fields: [gatewayId], references: [id], onDelete: Cascade)
  org       Org?             @relation(fields: [orgId], references: [id], onDelete: Cascade)
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([orgId])
  @@index([sessionId])
  @@index([isActive])
  @@index([lastSeen])
}

// Context Memory Models
model ContextMemory {
  id        String   @id @default(cuid()) @map("id")
  userId    String   @map("user_id")
  orgId     String   @map("org_id")
  
  // Content
  content     String   @db.Text
  contentType String   @map("content_type") // 'user_message', 'agent_message', 'document', 'decision', 'tool_result'
  metadata    Json     @default("{}")
  
  // Agent tracking
  agentId     String?  @map("agent_id") // Which app/agent created this? 'demo-chat', 'platform', 'docs-chat'
  agentName   String?  @map("agent_name") // Human-readable name
  
  // Vector embedding - pgvector type (768 dims)
  embedding   Unsupported("vector(768)")? @map("embedding")
  
  // Context tracking
  conversationId String? @map("conversation_id")
  parentId       String? @map("parent_id")
  correlationId  String? @map("correlation_id")
  
  // Temporal
  createdAt  DateTime  @default(now()) @map("created_at")
  updatedAt  DateTime  @updatedAt @map("updated_at")
  expiresAt  DateTime? @map("expires_at")
  
  // Governance
  isArchived      Boolean @default(false) @map("is_archived")
  piiDetected     Boolean @default(false) @map("pii_detected")
  piiRedacted     Boolean @default(false) @map("pii_redacted")
  rawContent      String? @map("raw_content") @db.Text // Original before redaction
  precheckDecision String? @map("precheck_decision") // 'allow', 'redact', 'block'
  
  // Scope
  scope       String  @default("user") @map("scope") // 'user' or 'org'
  visibility  String  @default("private") @map("visibility") // 'private', 'team', 'org'
  
  // Relations
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  organization Org         @relation(fields: [orgId], references: [id], onDelete: Cascade)
  conversation Conversation? @relation(fields: [conversationId], references: [id])
  parent       ContextMemory? @relation("ContextHierarchy", fields: [parentId], references: [id])
  children     ContextMemory[] @relation("ContextHierarchy")
  accessLogs   ContextAccessLog[]
  
  @@index([userId])
  @@index([orgId])
  @@index([agentId])
  @@index([conversationId])
  @@index([createdAt(sort: Desc)])
  @@index([contentType])
  @@index([scope, visibility])
  @@map("context_memory")
}

model Conversation {
  id     String @id @default(cuid())
  userId String @map("user_id")
  orgId  String @map("org_id")
  
  title   String?
  summary String?
  
  // Agent tracking
  agentId   String? @map("agent_id")
  agentName String? @map("agent_name")
  
  // Metadata
  messageCount Int   @default(0) @map("message_count")
  tokenCount   Int   @default(0) @map("token_count")
  cost         Float @default(0.0)
  
  // Tags
  tags String[] @default([])
  
  // Temporal
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")
  lastMessageAt DateTime? @map("last_message_at")
  
  // Governance
  isArchived Boolean @default(false) @map("is_archived")
  
  // Scope
  scope      String  @default("user") @map("scope") // 'user' or 'org'
  
  // Relations
  user         User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  organization Org            @relation(fields: [orgId], references: [id], onDelete: Cascade)
  contextMemory ContextMemory[]
  
  @@index([userId])
  @@index([orgId])
  @@index([agentId])
  @@index([updatedAt(sort: Desc)])
  @@map("conversations")
}

// RAG Documents
model Document {
  id     String @id @default(cuid())
  userId String @map("user_id") // Who uploaded it
  orgId  String @map("org_id")
  
  // Document metadata
  filename    String
  contentType String  @map("content_type") // 'pdf', 'txt', 'md', 'docx'
  fileSize    Int     @map("file_size") // bytes
  fileHash    String  @map("file_hash") // SHA256 for deduplication
  
  // Storage
  storageUrl  String? @map("storage_url") // S3/Railway storage URL
  content     String? @db.Text // Full text content
  
  // Processing status
  status      String  @default("pending") @map("status") // 'pending', 'processing', 'completed', 'failed'
  errorMessage String? @map("error_message") @db.Text
  
  // Chunking info
  chunkCount  Int     @default(0) @map("chunk_count")
  
  // Scope
  scope       String  @default("org") @map("scope") // Documents are usually org-scoped
  visibility  String  @default("org") @map("visibility")
  
  // Governance
  piiDetected     Boolean @default(false) @map("pii_detected")
  piiRedacted     Boolean @default(false) @map("pii_redacted")
  isArchived      Boolean @default(false) @map("is_archived")
  
  // Temporal
  createdAt  DateTime  @default(now()) @map("created_at")
  updatedAt  DateTime  @updatedAt @map("updated_at")
  expiresAt  DateTime? @map("expires_at")
  
  // Relations
  user         User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  organization Org            @relation(fields: [orgId], references: [id], onDelete: Cascade)
  chunks       DocumentChunk[]
  
  @@index([userId])
  @@index([orgId])
  @@index([fileHash])
  @@index([scope, visibility])
  @@index([status])
  @@map("documents")
}

// Document chunks for RAG
model DocumentChunk {
  id         String @id @default(cuid())
  documentId String @map("document_id")
  
  // Chunk content
  content    String @db.Text
  chunkIndex Int    @map("chunk_index") // Position in document
  
  // Vector embedding - pgvector type (768 dims)
  embedding  Unsupported("vector(768)")?  @map("embedding")
  
  // Metadata
  metadata   Json   @default("{}")
  
  // Governance
  piiDetected     Boolean @default(false) @map("pii_detected")
  piiRedacted     Boolean @default(false) @map("pii_redacted")
  rawContent      String? @map("raw_content") @db.Text
  
  // Temporal
  createdAt  DateTime @default(now()) @map("created_at")
  
  // Relations
  document   Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
  
  @@index([documentId])
  @@index([chunkIndex])
  @@map("document_chunks")
}

// Context access logging
model ContextAccessLog {
  id          String   @id @default(cuid())
  contextId   String?  @map("context_id")
  userId      String   @map("user_id")
  orgId       String   @map("org_id")
  accessType  String   @map("access_type") // 'search', 'read', 'write'
  query       String?
  resultsCount Int?    @map("results_count")
  createdAt   DateTime @default(now()) @map("created_at")
  
  // Relations
  context     ContextMemory? @relation(fields: [contextId], references: [id])
  user        User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  organization Org          @relation(fields: [orgId], references: [id], onDelete: Cascade)
  
  @@index([contextId])
  @@index([userId])
  @@index([orgId])
  @@index([accessType])
  @@index([createdAt])
  @@map("context_access_log")
}

enum OrgRole {
  OWNER
  ADMIN
  DEVELOPER
  VIEWER
}
